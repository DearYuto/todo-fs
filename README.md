## 1단계

### 🎯 목표

"입력 → 출력"만 존재하는 순수 함수를 직접 작성한다.

객체/배열을 직접 변경하지 않고 불변성을 유지하는 방법 습득한다.

자바스크립트 배열 함수인 map, filter, reduce를 함수형 스타일로 활용한다.

**미션1-1. 순수 함수 구현하기**

```
구현 조건
- 동일한 입력은 항상 동일한 출력을 가져야 함
- 외부 변수 사용 금지 (예: console.log, Math.random(), Date.now()는 X)
- 구현 사항은 App.tsx에 넣어서 결과확인하기.
```

- [x] add(a, b) → 두 수를 더해 결과를 반환 (부작용 없이)

- [x] multiply(a, b) → 곱셈 순수 함수

- [x] isEven(n) → 짝수인지 확인하는 순수 함수

**미션 1-2. 불변성 실습 (객체/배열)**

- [x] 객체를 직접 수정하지 않고, 새로운 객체로 반환

- [x] 원본 배열을 변경하지 않고 항목을 추가

**미션 1-3: map / filter / reduce 활용**

- [x] 숫자 배열에서 짝수만 필터링하고 제곱해서 합산

## 2단계

### 🎯 목표

함수를 인자로 받고, 함수를 반환하는 고차 함수(Higher-Order Function) 를 익힌다.

커링(currying), 함수 합성(pipe, compose) 개념을 이해하고 구현한다.

데이터 흐름을 함수로 연결하는 사고를 체화한다.

**미션2-1. 고차 함수 만들기**

- [ ] 전후로 로그를 찍는 고차 함수 withLogging(fn) 작성

**✅ 완료 조건 체크리스트**

- [ ] 인자를 받아 실행 전 [before] ... 로그 출력

- [ ] 원래 함수 실행 후 [after] ... 로그 출력

- [ ] 원래 함수의 반환값 그대로 반환

- [ ] 제네릭을 사용해 여러 타입의 함수에 적용 가능하도록 작성

```ts
구현 조건
- 인자로 받은 함수(fn)를 감싸는 고차 함수를 구현합니다.
- 호출 전에는 입력값을 [before] 로그로 출력하고,
- 호출 후에는 반환값을 [after] 로그로 출력해야 합니다.
- 원래 함수의 반환값은 그대로 반환해야 합니다.
- 다양한 시그니처의 함수에도 사용할 수 있도록 제네릭을 사용하세요.
- App.tsx에서 테스트 코드를 실행해 콘솔 로그를 확인하세요.

// 실행 예시

const double = (x: number) => x * 2;
const loggedDouble = withLogging(double);
loggedDouble(5);

// 콘솔 출력
[before] 5
[after] 10
```

**미션2-2. 커링(Currying)**

- [ ] 커링 함수 구현

**✅ 완료 조건 체크리스트**

- [ ] 인자가 하나씩 전달되도록 커링 구조로 변환

- [ ] 모든 인자를 전달받으면 원래 함수 실행

- [ ] 원래 함수와 동일한 결과 반환

- [ ] 제네릭 타입을 사용해 타입 안전하게 처리

```ts
구현 조건
- 다중 인자를 받는 함수를 커링 형태로 바꾸는 함수를 구현하세요.
- curry(fn)는 (a)(b)... 방식으로 원래 함수를 순차적으로 호출할 수 있게 합니다.
- 인자를 모두 전달받으면 원래 함수의 결과를 반환해야 합니다.
- 함수의 인자 개수는 최소 2개 이상이라고 가정합니다.
- App.tsx에서 테스트하여 결과를 확인하세요.

// 실행 예시

const sum = (a: number, b: number, c: number) => a + b + c;
const curriedSum = curry(sum);

const result = curriedSum(1)(2)(3);
console.log(result); // 6
```

**미션 2-3: pipe 함수 직접 구현**

- [ ] pipe 함수 구현

✅ 완료 조건 체크리스트

- [ ] 여러 함수를 왼쪽 → 오른쪽으로 순차적으로 실행

- [ ] 마지막 함수의 반환값을 그대로 반환

- [ ] 타입 추론을 지원하는 제네릭 함수로 구현

```ts
구현 조건
- pipe(...fns)는 여러 함수를 왼쪽 → 오른쪽으로 순차적으로 실행하는 함수입니다.
- pipe(f, g, h)(x)는 h(g(f(x)))와 동일한 결과를 반환해야 합니다.
- 첫 번째 함수는 단일 인자를 받고, 이후 함수들도 이전 함수의 결과를 받아야 합니다.
- 제네릭 타입을 사용해 타입 추론이 가능하도록 구현해 보세요.
- App.tsx에서 테스트 코드를 실행해 확인하세요.

// 실행 예시

const add1 = (n: number) => n + 1;
const double = (n: number) => n * 2;
const square = (n: number) => n * n;

const pipeline = pipe(add1, double, square);
console.log(pipeline(2)); // ((2 + 1) * 2)² = 36
```

**미션 2-4: compose 함수 직접 구현**

- [ ] compose 함수 구현

✅ 완료 조건 체크리스트

- [ ] 여러 함수를 오른쪽 → 왼쪽으로 순차적으로 실행

- [ ] 마지막 함수의 반환값을 그대로 반환

- [ ] 제네릭을 사용해 타입 추론 가능하도록 구현

```ts
구현 조건
- compose(...fns)는 여러 함수를 오른쪽 → 왼쪽으로 순차적으로 실행하는 함수입니다.
- compose(f, g, h)(x)는 f(g(h(x))) 와 동일한 결과를 반환해야 합니다.
- pipe와 반대로 동작해야 하며, 동일하게 제네릭 타입을 사용해 타입 안전성을 확보하세요.
- App.tsx에서 pipe와 비교해 결과를 테스트하세요.

// 실행 예시
const add1 = (n: number) => n + 1;
const double = (n: number) => n * 2;
const square = (n: number) => n * n;

const composed = compose(square, double, add1);
console.log(composed(2)); // square(double(add1(2))) = 36
```

---

### 구현 예정 순서

1단계: 순수 + 불변성

2단계: 함수 조합 (pipe / curry)

3단계: 상태 조작 로직을 함수화

4단계: reduce 중심 사고

5단계: 게으른 평가 (제너레이터)

6단계: 안전성 확보 (Option / Either)

7단계: 비동기 파이프라인

8단계: TodoApp에 통합
