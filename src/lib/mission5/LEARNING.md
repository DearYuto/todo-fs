## range 함수 구현 학습 기록

> 미션 개요

- function\* 문법을 사용하여 제너레이터 함수를 구현한다.
- 구현 조건은 아래 사항을 따른다.

```ts
구현 조건
- range(start, end) 형태의 제너레이터 함수를 구현합니다.
- start부터 end 전까지의 숫자를 순차적으로 yield합니다.
- 배열을 미리 만들지 않고 필요할 때마다 값을 생성합니다.
- for...of 문으로 순회 가능해야 합니다.

// 실행 예시
for (const n of range(1, 5)) {
  console.log(n); // 1, 2, 3, 4
}

// 배열로 변환
const arr = [...range(0, 10)];
console.log(arr); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

```

### 구현 로직

```ts
export function* range(start: number, end: number) {
  let i = start;
  while (i < end) {
    yield i++;
  }
}
```

### AI가 작성한 로직

```ts
export function* range(start: number, end: number) {
  for (let i = start; i < end; i++) {
    yield i;
  }
}
```

### 회고

> 추상적이었던 이론을 실체화해봤다!

제너레이트에 대해서는 정말 얕은 수준의 이론 지식정도만 알고 있었다.

단순히 yield 할 때 중단된다, 이터러블/이터레이터 프로토콜을 쉽게 구현할 수 있다(직접 Symbol.iterator를 구현하지 않아도 됨!), 메모리를 미리 만들어놓지 않고 필요할 때 생성할 수 있어서 무한 스트림 등에서 사용할 수 있다 정도만 알고 있었는데 이번 미션을 통해 처음으로 간단하지만 제너레이터를 써볼 수 있어서 좋았다.

다행히 아직은 문제의 난이도가 높진 않아서 나름 알고 있는 이론 지식으로 조합하니 문제는 쉽게 풀 수 있었던 것 같다.

> 제어 문법 어떤 것을 사용할까? for와 while 고민점

while과 for 두 가지 순회 문법중 어떤 것이 적절할지 고민하다 while을 선택했다.

제너레이터 = 무한 스트림 구현할 때 쓰기 좋다는 이미지에 갇혀서 조건이 충족될 때까지 계속 실행되어야 한다는 생각에 while을 선택했다.

AI 리뷰를 통해 코드가 의도를 얼마나 잘 표현하는가라는 관점에서 range는 범위 순회니까 for가 더 선언적이라는 피드백이 있었다. 기술적으로는 둘 다 정답이 될 수 있겠지만, 코드를 읽는 사람 입장에서는 for문이 더 나은 대안이 될 수도 있겠다는 생각이 들었다.
물론 둘 다 명확하게 동작하므로 팀 컨벤션에 따라가면 좋을 것 같다.

> range 함수의 실무형 사용법에 대해 배웠다.

AI 리뷰를 통해 실무에서는 step이라는 추가 파라미터를 넣는 경우도 있다고 한다.

아마 숫자를 건너뛸 수 있게 제공해야하는 경우에 사용되는 듯 하다.

단순히 미션을 구현해야겠다는 생각으로 구현에만 집중했었는데, 이런 요구 사항이 실무에서 어떻게 사용될지에 대해서도 더 고민해보는 과정을 즐기면 좋을 것 같다고 느꼈다.

> 개발자로서 고민.. 오버 엔지니어링의 경계ㅠㅠ

새로운 기술이나 패턴을 배우면 어떻게든 코드에 적용해보고 싶은 욕심이 생기곤 한다.

최근까지도 그런 욕심때문에 나름 아키텍쳐를 잘 짰다고 뿌듯해했었는데, 팀원이 '추상화를 너무 좋아하는 것 같다', '오버엔지니어링 아니냐'는 피드백을 받은 적이 있었다. ㅠ.ㅠ..

피드백을 받은 이후로는 무조건 좋아보이는 아키텍쳐나 복잡한 패턴을 선택하는 것보다 현재 문제 상황에 가장 적합한 도구를 선택하는 눈을 기르는 게 좋을 것 같다고 생각했는데, 이번 문제를 풀면서 또 제너레이터 어디엔가 써보고 싶어서 발을 동동 구르고 있을 내가 보여서 조금은 자제하려고 노력중이다..ㅋㅋ
